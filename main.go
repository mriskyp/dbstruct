package main

import (
	"database/sql"
	"fmt"
	"strings"
	"time"

	conv "dbstruct/converts"

	_ "github.com/go-sql-driver/mysql"
	_ "github.com/lib/pq"
)

const (
	autoStructData = `type AutoGeneratedDB struct {` + "%s" + "\n" + `}`
	tempStructData = "\t" + `%s %s "` + `json:"%s"` + ` db:"%s"` + "`"

	mysqlType    = "mysql"
	postgresType = "postgres"

	dbExpression = `SELECT column_name , ordinal_position ,is_nullable ,data_type, column_type 
	FROM INFORMATION_SCHEMA.COLUMNS 
	WHERE TABLE_NAME like ? ;
	`
	preparePsql = "host=%s port=%d user=%s " + "password=%s dbname=%s sslmode=disable"
)

func main() {
	dbHost := "10.107.224.23"
	dbPort := "3306"
	dbName := "lemonilo_staging"
	dbUser := "administrator"
	dbPassword := "T3ch*123*mysqlstaging*tw0"
	dbType := "mysql"
	tableName := "tableName"

	initializeDB(dbType, dbHost, dbPort, dbUser, dbPassword, dbName, tableName)
}

func initializeDB(dbType, host, port, user, password, dbname, tableName string) {
	// initialize db
	var db *sql.DB

	if dbType == postgresType {
		psqlInfo := fmt.Sprintf(preparePsql,
			host, port, user, password, dbname)
		dbMysql, err := sql.Open(postgresType, psqlInfo)
		if err != nil {
			panic(err)
		}
		db = dbMysql
	}

	if dbType == mysqlType {
		dbPostgres, err := sql.Open(mysqlType, user+":"+password+"@tcp("+host+":"+port+")/"+dbname)
		if err != nil {
			panic(err)
		}
		db = dbPostgres
	}
	defer db.Close()

	err := db.Ping()
	if err != nil {
		panic(err)
	}

	fmt.Println("Successfully connected!")

	var totalElapsedTime time.Duration
	start := time.Now()

	rows, err := db.Query(dbExpression, tableName)

	elapsed := time.Since(start)

	totalElapsedTime += elapsed
	fmt.Println("\n query processing time %s \n", elapsed)

	if err != nil {
		// handle this error better than this
		panic(err)
	}

	fmt.Printf("\n get query rows :%+v \n", rows)

	defer rows.Close()
	var totalAppendData string
	for rows.Next() {
		var columnName, columnType, dataType, isNullable, typeData string
		var ordinalPosition int
		var isNull bool
		err = rows.Scan(&columnName, &ordinalPosition, &isNullable, &dataType, &columnType)
		if err != nil {
			// handle this error
			panic(err)
		}
		if isNullable == "YES" {
			isNull = true
			typeData = "null.%s"
		} else {
			typeData = dataType
		}

		if dataType == "enum" {
			if isNull {
				typeData = fmt.Sprintf(typeData, "String")
			} else {
				typeData = "string"
			}
		}

		if dataType == "date" {
			if isNull {
				typeData = fmt.Sprintf(typeData, "String")
			} else {
				typeData = "string"
			}
		}

		if dataType == "datetime" || dataType == "time" {
			if isNull {
				typeData = fmt.Sprintf(typeData, "Time")
			} else {
				typeData = "*time.Time"
			}
		}

		if strings.Contains(dataType, "int") {
			if isNull {
				typeData = fmt.Sprintf(typeData, "Int")
			} else {
				typeData = "int64"
			}
		}

		if strings.Contains(dataType, "decimal") {
			if isNull {
				typeData = fmt.Sprintf(typeData, "Float")
			} else {
				typeData = "float64"
			}
		}

		if strings.Contains(dataType, "boolean") {
			if isNull {
				typeData = fmt.Sprintf(typeData, "Bool")
			} else {
				typeData = "bool"
			}
		}

		if strings.Contains(dataType, "char") || strings.Contains(dataType, "text") {
			if isNull {
				typeData = fmt.Sprintf(typeData, "String")
			} else {
				typeData = "string"
			}
		}

		splittedColumnName := strings.Split(columnName, "_")
		var tempData string
		var appendString string
		if len(splittedColumnName) > 0 {
			for i := 0; i < len(splittedColumnName); i++ {
				tempData = conv.UpperInitial(splittedColumnName[i])
				appendString = fmt.Sprintf("%s%s", appendString, tempData)
			}
		} else {
			appendString = conv.UpperInitial(dataType)
		}

		parserNameType := appendString
		parserJSONType := conv.LowerInitial(parserNameType)

		fmt.Println("")
		fmt.Println("---------------check type data---------------")
		fmt.Println("")

		fmt.Println(appendString)
		fmt.Println(columnName, ordinalPosition, isNullable, dataType, columnType)
		// appendData := fmt.Sprintf(columnName, ordinalPosition, isNullable, dataType, columnType)
		appendData := fmt.Sprintf(tempStructData, parserNameType, typeData, parserJSONType, columnName)
		totalAppendData = fmt.Sprintf("%s\n%s", totalAppendData, appendData)
	}

	fmt.Println("")
	fmt.Println("---------------auto generated struct---------------")
	fmt.Println("")

	if totalAppendData != "" {
		totalStruct := fmt.Sprintf(autoStructData, totalAppendData)
		fmt.Println(totalStruct)
	}
}
