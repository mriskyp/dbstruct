package main

import (
	"database/sql"
	"errors"
	"fmt"
	"io/ioutil"
	"log"
	"strings"
	"time"

	conv "github.com/dbstruct/convert"
	"github.com/ghodss/yaml"
	"github.com/mriskyp/dbstruct/model"

	_ "github.com/go-sql-driver/mysql"
	_ "github.com/lib/pq"
)

const (
	autoStructData = `type AutoGeneratedDB struct {` + "%s" + "\n" + `}`
	tempStructData = "\t" + `%s %s "` + `json:"%s"` + ` db:"%s"` + "`"

	mysqlType    = "mysql"
	postgresType = "postgres"
)

func main() {

	cfg, err := generateFromYml()
	if err != nil {
		panic(err)
	}

	fmt.Printf("\n data cfg %+v \n", cfg)
	initializeDB(cfg.DBType, cfg.DBHost, cfg.DBPort, cfg.DBUser, cfg.DBPassword, cfg.DBName, cfg.TableName)
}

func generateFromYml() (*model.Config, error) {

	data, err := ioutil.ReadFile("generate.yml")
	if err != nil {
		log.Fatalln(err)
		return nil, errors.New("invalid yml config file")
	}

	var mapConfig map[string]model.Config

	err = yaml.Unmarshal(data, &mapConfig)
	if err != nil {
		log.Fatalln(err)
	}

	configData := mapConfig["generate-dbstruct"]

	// return data config
	return &configData, nil
}

func initializeDB(dbType, host, port, user, password, dbname, tableName string) {
	// initialize db
	var db *sql.DB

	if dbType == postgresType {
		psqlInfo := fmt.Sprintf("host=%s port=%d user=%s "+"password=%s dbname=%s sslmode=disable",
			host, port, user, password, dbname)
		dbPsql, err := sql.Open(postgresType, psqlInfo)
		if err != nil {
			panic(err)
		}
		db = dbPsql
	}

	if dbType == mysqlType {
		dbMysql, err := sql.Open(mysqlType, user+":"+password+"@tcp("+host+":"+port+")/"+dbname)
		if err != nil {
			panic(err)
		}
		db = dbMysql
	}
	defer db.Close()

	err := db.Ping()
	if err != nil {
		panic(err)
	}

	fmt.Println("Successfully connected!")

	var totalElapsedTime time.Duration
	start := time.Now()

	rows, err := db.Query(`SELECT column_name , ordinal_position ,is_nullable ,data_type, column_type 
	FROM INFORMATION_SCHEMA.COLUMNS 
	WHERE TABLE_NAME like ? ;
	`, tableName)

	if err != nil {
		// handle this error better than this
		panic(err)
	}

	fmt.Printf("\n get query rows :%+v \n", rows)

	defer rows.Close()
	var totalAppendData string

	fmt.Println("")
	fmt.Println("---------------check type data---------------")
	fmt.Println("")

	for rows.Next() {
		var columnName, columnType, dataType, isNullable, typeData string
		var ordinalPosition int
		var isNull bool
		err = rows.Scan(&columnName, &ordinalPosition, &isNullable, &dataType, &columnType)
		if err != nil {
			// handle this error
			panic(err)
		}
		if isNullable == "YES" {
			isNull = true
			typeData = "null.%s"
		} else {
			typeData = dataType
		}

		if dataType == "enum" {
			if isNull {
				typeData = fmt.Sprintf(typeData, "String")
			} else {
				typeData = "string"
			}
		}

		if dataType == "date" {
			if isNull {
				typeData = fmt.Sprintf(typeData, "String")
			} else {
				typeData = "string"
			}
		}

		if dataType == "datetime" || dataType == "time" {
			if isNull {
				typeData = fmt.Sprintf(typeData, "Time")
			} else {
				typeData = "*time.Time"
			}
		}

		if strings.Contains(dataType, "int") {
			if isNull {
				typeData = fmt.Sprintf(typeData, "Int")
			} else {
				typeData = "int64"
			}
		}

		if strings.Contains(dataType, "decimal") {
			if isNull {
				typeData = fmt.Sprintf(typeData, "Float")
			} else {
				typeData = "float64"
			}
		}

		if strings.Contains(dataType, "boolean") {
			if isNull {
				typeData = fmt.Sprintf(typeData, "Bool")
			} else {
				typeData = "bool"
			}
		}

		if strings.Contains(dataType, "char") || strings.Contains(dataType, "text") {
			if isNull {
				typeData = fmt.Sprintf(typeData, "String")
			} else {
				typeData = "string"
			}
		}

		splittedColumnName := strings.Split(columnName, "_")
		var tempData string
		var appendString string
		if len(splittedColumnName) > 0 {
			for i := 0; i < len(splittedColumnName); i++ {
				tempData = conv.UpperInitial(splittedColumnName[i])
				appendString = fmt.Sprintf("%s%s", appendString, tempData)
			}
		} else {
			appendString = conv.UpperInitial(dataType)
		}

		parserNameType := appendString
		parserJSONType := conv.LowerInitial(parserNameType)

		fmt.Println(appendString)
		fmt.Println(columnName, ordinalPosition, isNullable, dataType, columnType)

		appendData := fmt.Sprintf(tempStructData, parserNameType, typeData, parserJSONType, columnName)
		totalAppendData = fmt.Sprintf("%s\n%s", totalAppendData, appendData)
	}

	fmt.Println("")
	fmt.Println("---------------auto generated struct---------------")
	fmt.Println("")

	if totalAppendData != "" {
		totalStruct := fmt.Sprintf(autoStructData, totalAppendData)
		fmt.Println(totalStruct)
	}

	elapsed := time.Since(start)

	totalElapsedTime += elapsed
	fmt.Println("\n query processing time %s \n", elapsed)

}
